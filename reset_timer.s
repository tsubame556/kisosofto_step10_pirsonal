*----------------------------------------------------------------------
* RESET_TIMER ルーチン (タイマ停止 & 割り込み禁止)
*
* 役割: タイマーを安全に停止し、割り込みを禁止する。
*プログラムがタイマーを再設定する前や、タイマーの使用を完全に終えるときに、システムコール（TRAP #0経由のSYSCALL_RESET_TIMER）として呼び出される。
*----------------------------------------------------------------------
RESET_TIMER:
        move.l  #TCTL1, %A0        /* A0 に TCTL1 のアドレスをロード */
        *タイマー1の動作を制御するレジスタ（TCTL1）にアクセスする準備として、そのメモリアドレス（REGBASE+0x600）をアドレスレジスタ%A0にロード
        andi.w  #0xFFFE, (%A0)     /* タイマー停止 (TCTL1 Bit 0 'TEN' = 0) */
        *TCTL1レジスタのビット0（Timer Enable, TEN）のみを強制的に0にし、
        *0xFFFE は2進数で ...1111 1110であり、andi.w　命令は、(%A0)が指すTCTL1レジスタの現在の値と0xFFFEのビット単位のAND演算を行いビット0（TENフラグ）は & 0 されて 0 となり、他のビット（ビット1～15）は & 1 されてそのままの値が保持される。
     
        move.l  #IMR, %A0          /* A0 に IMR のアドレスをロード */
        *次にCPU全体の割り込みマスクレジスタ（IMR）を操作するため、そのアドレス（REGBASE+0x304）を%A0にロード
        * IMR Bit 1 (Timer1) を 1 (マスク/禁止) に設定する
        ori.l   #0x00000002, (%A0)
        *0x00000002 は2進数で ...0010であり、ori.l命令は、IMRの現在の値と0x00000002のビット単位のOR演算を行う。
        *このハードウェアでは、タイマー1の割り込みはIMRのビット1に対応している。このビットを1にすることで、タイマー1の割り込みがマスクされる。
     
        move.w  #0x0000, TSTAT1   /* 保留中の割り込みフラグをクリア */
        *タイマー1のステータスレジスタ（TSTAT1）をクリアし、万が一、タイマー停止処理（andi.w）と割り込みマスク（ori.l）の間にコンペアマッチが発生して割り込みフラグ（COMPフラグ）が立っていたとしても、それをリセット
        rts
        *呼び出し元（TRAP0_HANDLER）に処理を戻す
        *TSTAT1のビット0（COMPフラグ）は、0を書き込むことでクリアされる仕様になっている。これを怠ると、次にタイマーを有効化した瞬間に、古いフラグによって意図しない割り込みが発生する可能性があるため、安全策として必須の処理である。
