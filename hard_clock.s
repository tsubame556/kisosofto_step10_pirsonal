* mtk_asm.s - マルチタスクカーネル アセンブリ言語ルーチン
* hard_clock: タイマー割り込みハンドラ (タスクスイッチのトリガー)

* ----------------------------------------------------------------------
* 外部参照（C言語カーネル部や他のアセンブリルーチン）
* ----------------------------------------------------------------------
	.extern curr_task		/* 現在実行中のタスクID (C変数) */
	.extern next_task		/* 次に実行するタスクID (C変数) */
	.extern ready			/* Readyキューの先頭ポインタ (C変数) */
	.extern addq			/* Readyキューの末尾に追加するC関数 */
	.extern sched			/* スケジューラC関数 */
	.extern swtch			/* タスク切り替え本体アセンブリ関数 */

* ----------------------------------------------------------------------
* グローバル宣言
* ----------------------------------------------------------------------
	.global hard_clock		/* 割り込みベクタに登録されるエントリ */
	.global swtch			/* (swtchは他の場所からも呼ばれるためglobalにする) */

* ----------------------------------------------------------------------
* 定義（必要に応じてequdefs.incから持ってくる）
* ----------------------------------------------------------------------
	.equ IPR, 0xFFF310		/* 割り込みペンディングレジスタ (mon.sより) */
	.equ TSTAT1, 0xFFF60a	/* タイマ１ステータスレジスタ (mon.sより) */

.text
.even

*----------------------------------------------------------------------
* hard_clock: タイマ割り込みハンドラ
* 役割: タイマ割り込み時にタスクをReadyキューに戻し、次のタスクへ切り替える。
* (割り込み駆動であるが、前期インターフェースから呼ばれるため、RTSで復帰する)
*----------------------------------------------------------------------
hard_clock:
	* [要件1] 実行中のタスクのレジスタの退避
	* D0-D7, A0-A6 をスタックに退避 (完全なコンテキストスイッチではないため、ここでは簡略化)
	movem.l %D0-%D7/%A0-%A6, -(%SP) 

	* 割り込み要因を確認し、フラグをクリアする処理（mon.sのtimer1_interruptから流用）
	* TSTAT1のCOMPフラグをクリア
	move.w 	#0x0000, TSTAT1 

	* ------------------------------------------------------------------
	* 【タスクスイッチ ロジック】
	* ------------------------------------------------------------------

	* [要件2] addq()により、curr_taskをreadyの末尾に追加。
	* 1. curr_task の値を引数としてスタックに積む (addq(curr_task))
	lea.l 	curr_task, %A0			/* curr_task変数のアドレスをA0に */
	move.l 	(%A0), %D0				/* D0 = curr_task の値 (タスクID) */
	move.l 	%D0, -(%SP)				/* D0 (curr_task ID) をスタックにプッシュ */

	* 2. ready キューのアドレスを引数としてスタックに積む
	lea.l 	ready, %A0				/* readyキューのアドレスをA0に */
	move.l 	%A0, -(%SP)				/* A0 (readyアドレス) をスタックにプッシュ */

	* 3. addq 関数を呼び出す
	jsr 	addq					/* addq(ready, curr_task) を実行 */
	
	* 4. スタックポインタの補正 (呼び出し側がスタックをクリーン)
	adda.l 	#8, %SP					/* 引数2つ分 (4byte * 2 = 8byte) をスタックから除去 */

	* [要件3] schedを起動 (next_taskにIDがセットされる)
	jsr 	sched					/* sched() を実行 */

	* [要件4] swtchを起動
	jsr 	swtch					/* swtch() を実行 */

	* swtchは通常、RTEで復帰するため、この後のコードは実行されない（戻ってきた場合はエラー）。
	* ただし、タスクスイッチが発生しない場合もあるため、念のためレジスタ復帰コードを配置する。

.hard_clock_exit:
	* [要件5] レジスタの復帰
	movem.l (%SP)+, %D0-%D7/%A0-%A6 	/* 退避したレジスタを復帰 */

	rts							/* 呼び出し元（ハードウェア割り込みインターフェース）に復帰 */
